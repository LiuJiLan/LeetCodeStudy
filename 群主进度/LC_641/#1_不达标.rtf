{\rtf1\ansi\ansicpg936\cocoartf2569
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fnil\fcharset0 Monaco;\f1\fnil\fcharset134 PingFangSC-Regular;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural\partightenfactor0

\f0\fs28 \cf0 //2020.09.13_#1_
\f1 \'b2\'bb\'b4\'ef\'b1\'ea
\f0 \
//
\f1 \'d7\'a2\'d2\'e2\'a3\'ba
\f0 \
//1_
\f1 \'b5\'b1\'d3\'d0
\f0  - 1
\f1 \'ca\'b1\'d2\'aa\'bc\'d3\'c9\'cf
\f0 size
\f1 \'d4\'d9
\f0  % size 
\f1 \'c0\'b4\'b1\'dc\'c3\'e2\'b8\'ba\'ca\'fd\'b5\'c4\'b4\'ed\'ce\'f3
\f0 \
//2_
\f1 \'b7\'b5\'bb\'d8\'d6\'b5\'b5\'c4\'bb\'b0\'bc\'c7\'b5\'c3\'bf\'bc\'c2\'c7\'d2\'ec\'b3\'a3\'ca\'b1\'b5\'c4\'b7\'b5\'bb\'d8\'d6\'b5\'a3\'ac\'c3\'bf\'d2\'bb\'b8\'f6\'ca\'b5\'cf\'d6\'b5\'c4\'b6\'bc\'d2\'aa\'bc\'c7\'b5\'c3\'d5\'e2\'d2\'bb\'b5\'e3
\f0 \
\
class MyCircularDeque \{\
private:\
    vector<int> elements;\
    int count;\
    int size;\
    int head;\
    int tail;\
    \
public:\
    /** Initialize your data structure here. Set the size of the deque to be k. */\
    MyCircularDeque(int k) \{\
        elements = vector<int>(k, 0);\
        count = 0;\
        size = k;\
        head = k - 1;\
        tail = 0;\
    \}\
    \
    /** Adds an item at the front of Deque. Return true if the operation is successful. */\
    bool insertFront(int value) \{\
        if (count == size) \{\
            return false;\
        \}\
        \
        elements[head] = value;\
        head = (head - 1 + size) % size;\
        count++;\
        \
        return true;\
    \}\
    \
    /** Adds an item at the rear of Deque. Return true if the operation is successful. */\
    bool insertLast(int value) \{\
        if (count == size) \{\
            return false;\
        \}\
        \
        elements[tail] = value;\
        tail = (tail + 1) % size;\
        count++;\
        \
        return true;\
    \}\
    \
    /** Deletes an item from the front of Deque. Return true if the operation is successful. */\
    bool deleteFront() \{\
        if (count == 0) \{\
            return false;\
        \}\
        \
        head = (head + 1) % size;\
        count--;\
        \
        return true;\
    \}\
    \
    /** Deletes an item from the rear of Deque. Return true if the operation is successful. */\
    bool deleteLast() \{\
        if (count == 0) \{\
            return false;\
        \}\
        \
        tail = (tail - 1 + size) % size;\
        count--;\
        \
        return true;\
    \}\
    \
    /** Get the front item from the deque. */\
    int getFront() \{\
        if (count == 0) \{\
            return -1;\
        \}\
        \
        return elements[(head + 1) % size];\
    \}\
    \
    /** Get the last item from the deque. */\
    int getRear() \{\
        if (count == 0) \{\
            return -1;\
        \}\
        \
        return elements[(tail - 1 + size) % size];\
    \}\
    \
    /** Checks whether the circular deque is empty or not. */\
    bool isEmpty() \{\
        return count == 0;\
    \}\
    \
    /** Checks whether the circular deque is full or not. */\
    bool isFull() \{\
        return count == size;\
    \}\
\};\
\
/**\
 * Your MyCircularDeque object will be instantiated and called as such:\
 * MyCircularDeque* obj = new MyCircularDeque(k);\
 * bool param_1 = obj->insertFront(value);\
 * bool param_2 = obj->insertLast(value);\
 * bool param_3 = obj->deleteFront();\
 * bool param_4 = obj->deleteLast();\
 * int param_5 = obj->getFront();\
 * int param_6 = obj->getRear();\
 * bool param_7 = obj->isEmpty();\
 * bool param_8 = obj->isFull();\
 */}